# タスク

## [ ] 内部実装の調査依頼
- Boardクラスについて、今どこになんのカードをおいたら、役になりうるか？を返すメソッドの実装は可能かしりたい
- 意図としては、CPUのカード配置戦略のロジックに利用できるかもしれないとおもっている
- 全てのパターンを網羅的に出すひつようはなく、「候補の一部を出す」、という意味のメソッドでよい（計算量をおさえる）
- そのメソッド結果をもとにして、CPUの戦略ではそのカードが手札にあれば、それをおくという風にできないか
- ~~まずは意意だけほしい、以下に意見をかいてほしい~~
- 下記の調査結果をもとにした、推奨実装を進めてほしい

### Claudeの意見

#### 結論：実装は十分可能です

提案されたメソッド `Board.suggestWinningPlacements()` は実装可能で、CPU戦略に有効活用できます。

#### 実装アプローチ

**メソッドシグネチャ案：**
```typescript
// Boardクラスに追加
suggestWinningPlacements(hand: Card[]): PlacementSuggestion[]

interface PlacementSuggestion {
  card: Card;           // 手札のどのカード
  position: Position;   // どの位置に置くか
  comboType: ComboType; // 成立する役の種類
  priority: number;     // 優先度（調調=4, 3枚役=3, 4-9=2, 1-4=1）
}
```

**アルゴリズム概要：**
```
1. 手札の各カードについて
2. 盤面の空きマス（最大9箇所）を全てチェック
3. 仮想的に配置してComboDetector.detectCombos()を実行
4. 役が成立する場合、PlacementSuggestionとして記録
5. 優先度順（調調 > 3枚役 > 4-9 > 1-4）でソートして返却
```

**計算量：**
- 最悪ケース：O(手札サイズ × 9マス × 役判定コスト)
- 手札=5枚、盤面=空き9マス → 最大45パターンのチェック
- 各役判定は既存のComboDetectorを再利用するため高速
- **実用上問題なし**

#### なぜ実装可能か

1. **ComboDetectorが既に独立している**
   - `ComboDetector.detectCombos(board, position)` は既存メソッド
   - ボードを変更せずに仮想配置での判定が可能

2. **明確な役の種類**
   - 4種類の役のみ（1-4、4-9、1-4-16、調調）
   - 優先度付けが容易

3. **盤面サイズが小さい**
   - 3×3=9マスのみ
   - 全探索しても計算コストが低い

#### CPU戦略での活用方法

**Normal難易度での実装例：**
```typescript
// CPUのターン処理
const suggestions = board.suggestWinningPlacements(cpuHand);

// 5%の確率で見落とし（Normal仕様）
if (Math.random() < 0.05) {
  // ランダム配置にフォールバック
  return randomPlacement(cpuHand);
}

// 優先度の高い順に配置
if (suggestions.length > 0) {
  const bestSuggestion = suggestions[0]; // すでに優先度順
  return { card: bestSuggestion.card, position: bestSuggestion.position };
}

// 役が成立しない場合は戦略的ランダム配置
return strategicRandomPlacement(cpuHand); // 1→16→9→4の優先順位
```

#### 実装上の考慮点

1. **「候補の一部を出す」方針について**
   - 全パターンチェックでも計算量は小さいため、全候補を返却することを推奨
   - 呼び出し側で「上位N件だけ使う」「ランダムに1件選ぶ」などの制御が可能
   - 柔軟性が高い

2. **Board vs Gameレイヤー**
   - 現状、Boardは純粋な盤面管理のみ
   - 役判定はComboDetectorが担当
   - **提案：** `ComboDetector.suggestWinningPlacements(board, hand)` として実装する方が設計的に自然
   - これにより責務の分離を維持できる

3. **パフォーマンス最適化（必要に応じて）**
   - 「調調が成立する位置が見つかったら即座に返す」など早期リターンも可能
   - 現状の盤面サイズでは不要な最適化の可能性が高い

#### 推奨する実装方針

1. **ComboDetectorクラスに `suggestWinningPlacements()` メソッドを追加**
2. **全候補を優先度順で返却**（呼び出し側で制御）
3. **既存のdetectCombos()ロジックを最大限再利用**
4. **CPU戦略レイヤーでこのメソッドを活用**

この設計により、Normal/Hard難易度のCPUが戦略的にカードを配置できるようになり、ゲームの面白さが大幅に向上します。


## [x] CPU（Noarmal）の行動仕様書をつくってほしい
- ✅ ./docs/cpu_easy_spec.md を参考にして別ファイルでつくること
- ✅ 以下をNormal用の戦略とする
  - 役の見落とし率は、5%にする
  - 盤面をみて、役が成立できるなら、以下の順位でカードをおく
    1. 1-4-16の3枚役を申告
    2. 4-9の2枚役を申告（優先順位を1-4より上に変更）
    3. 1-4の2枚役を申告
    4. 調調を申告
  - 成立可能な役がないなら、以下の順位でランダムにカードをおく
    1. 1をおく（役の起点として最重要）
    2. 16をおく
    3. 9をおく
    4. 4をおく
  - ✅ まずはこのNormalの仕仕様ついて意見を記載
  - ✅ `docs/cpu_normal_spec.md` を作成完了（2026-02-02）

### Claudeの意見

#### 良い点
1. **段階的な難易度設計**
   - 見落とし率：Easy 20% → Normal 5% → Hard 0%（予想）という自然な難易度曲線
   - プレイヤーが成長を実感しやすい設計

2. **役の優先順位が明確**
   - 3枚役 > 2枚役（4-9） > 2枚役（1-4） > 調調という優先順位は合理的
   - 星の獲得数を最大化する戦略として妥当

3. **Easyとの明確な差別化**
   - Easyは「ランダム配置→役確認」
   - Normalは「役成立を狙って配置→失敗時ランダム」
   - 戦略性のレベルが明確に異なる

#### 検討が必要な点

1. **ランダム配置時の優先順位について**
   - 現在の提案：16 > 9 > 1 > 4
   - 疑問点：なぜ「1」が「4」より優先度が低いのか？
   - 提案：**1 > 16 > 9 > 4** の方が戦略的では？
     - 理由：1は全ての役（1-4、1-4-16）の起点となる最重要カード
     - 4は1がないと役を作れないため、1より優先度が低い
     - 16と9は大きい数字だが、単体では役を完成させにくい

2. **「役が成立できるなら置く」の実装難易度**
   - この戦略は「カードを置く前に、役が成立する位置を探す」という先読み能力が必要
   - Easy実装（置いてから役を確認）よりも複雑な実装になる
   - 提案：以下のようなアルゴリズムが必要
     ```
     1. 手札の各カードについて
     2. 盤面の空きマス全てをチェック
     3. 仮置きして役が成立するか検証
     4. 成立する配置があれば優先順位に従って選択
     5. なければランダム配置
     ```

3. **実装の明確化が必要な点**
   - 複数の配置で同じ役が成立する場合、どれを選ぶ？（ランダム？）
   - 手札に複数カードがあり、それぞれ異なる役が成立する場合の優先順位は？
     - 例：手札に1と9がある時、1で「1-4」役、9で「4-9」役が両方成立可能な場合
     - 提案：役の優先順位（3枚役 > 4-9 > 1-4）で判断

#### 推奨する修正案

**成立可能な役がないときのランダム配置優先順位**を以下に変更：
```
1. 1をおく（役の起点として最重要）
2. 16をおく（3枚役の完成に必要）
3. 9をおく（4-9役の完成に必要）
4. 4をおく（単体での戦略的価値が最も低い）
```

**または、より戦略的なアプローチ**：
- ランダム配置時も「将来の役成立を考慮」する
- 例：既に盤面に4があるなら、1や9を優先的に配置
- これによりNormalの戦略性がさらに向上