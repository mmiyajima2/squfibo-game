# CPU（Normal）仕様書

## 概要
CPU（Normal）は、SquFiboゲームにおける中級レベルのAI対戦相手です。
戦略的にカードを配置し、役の成立を狙う振る舞いを持ちますが、わずかに役を見落とすことがあります。

---

## 難易度コンセプト
- **対象プレイヤー**：ゲームのルールを理解し、役を意識してプレイできるようになった中級者
- **強さレベル**：中級（役の見落とし率5%）
- **プレイスタイル**：戦略的で、役の成立を狙って配置する
- **教育的価値**：プレイヤーに「先読み」や「戦略的配置」の重要性を学ばせる

---

## 基本的な振る舞い

### 1. カード配置の戦略

CPU（Normal）は以下の手順でカードを配置します：

#### 1.1 盤面が満杯の場合
- **処理**：盤面上のカードを1枚除去してから配置
- **選択方法**：ランダムに1枚選んで捨て札にする
- **考慮事項**：特に戦略的な判断は行わない（Normal難易度では盤面管理までは行わない）

#### 1.2 手札がある場合（戦略的配置）
CPU（Normal）の核心となる戦略部分です。

**手順**：
1. **役成立可能性の探索**
   - 手札の各カードについて、盤面の空きマス全てに対して仮置きをシミュレート
   - `ComboDetector.detectCombos()`を使用して、役が成立するかチェック
   - 成立する配置候補をリスト化

2. **配置候補の優先順位判定**
   - 複数の配置候補がある場合、以下の優先順位で1つ選択：
     1. **THREE_CARDS**（1+4+16の3枚役）を成立させる配置
     2. **TWO_CARDS_4_9**（4+9の2枚役）を成立させる配置
     3. **TWO_CARDS_1_4**（1+4の2枚役）を成立させる配置
     4. **CLEARING_YAKU**（調調）を成立させる配置
   - 同じ優先度の配置が複数ある場合はランダムに選択

3. **役が成立しない場合のランダム配置**
   - 役が成立する配置が1つもない場合、以下の優先順位でカードを配置：
     1. **1**をランダムな空きマスに置く（役の起点として最重要）
     2. **16**をランダムな空きマスに置く（3枚役の完成に必要）
     3. **9**をランダムな空きマスに置く（4-9役の完成に必要）
     4. **4**をランダムな空きマスに置く（単体での戦略的価値が低い）
   - 手札に該当する数字がない場合は、次の優先順位のカードを配置
   - 空きマスの選択はランダム

#### 1.3 手札が0枚の場合
- **処理**：山札の一番上のカードを1枚引き、そのまま配置（ゲームルール通り）
- **選択方法**：
  1. 引いたカードで役が成立する位置を探索（1.2の手順1-2と同じ）
  2. 役が成立する位置があればその位置に配置
  3. なければランダムな空きマスに配置

---

### 2. 役の検出と申告の戦略

#### 2.1 役の検出
カード配置後、`ComboDetector.detectCombos(board, lastPlacedPosition)`を使用して、
今回置いたカードを含む成立可能な役を全て検出します。

検出される可能性のある役：
- **TWO_CARDS_1_4**：赤または青の1+4（星2個）
- **TWO_CARDS_4_9**：赤または青の4+9（星2個）
- **THREE_CARDS**：赤または青の1+4+16（星3個）
- **CLEARING_YAKU**：赤または青の同じ数字3枚（盤面全消去、星なし）

#### 2.2 役の申告判定（見落とし機構）

**重要：CPU（Normal）の特徴的な振る舞い**

役が検出された場合、以下のロジックで申告するかどうかを決定します：

```
if (検出された役がある) {
  ランダムに1～20の整数を生成

  if (生成された値が20) {
    // 5%の確率（20分の1）
    → 役を見落とす：申告せずにターン終了
  } else {
    // 95%の確率（20分の19）
    → 役を申告する
  }
}
```

**実装のポイント**：
- 乱数生成は各ターンごとに独立して行う
- 見落とし判定は役の種類に関わらず一律5%
- 見落とした場合、役は成立しなかったものとして処理される
- Easy（20%）と比較して大幅に見落とし率が低い

#### 2.3 複数の役がある場合の優先順位

複数の役が検出された場合、以下の優先順位で1つだけ選択します：

1. **THREE_CARDS**（1+4+16）
   - 理由：最も多くの星（3個）を獲得できるため
2. **TWO_CARDS_4_9**（4+9）
   - 理由：2枚役の中で大きい数字の組み合わせ
3. **TWO_CARDS_1_4**（1+4）
   - 理由：2枚役の基本
4. **CLEARING_YAKU**（同じ数字3枚）
   - 理由：星が獲得できないため最低優先

**注意**：見落とし判定（5%）は、この優先順位選択の**後**に行われます。

---

### 3. ゲーム終了判定への対応

CPU（Normal）は以下の終了条件を自動的に認識します：
- 場の星がすべて獲得されたとき
- 山札が0枚になったとき

終了条件に達した場合、自動的にゲーム終了となり、星の数で勝敗が決まります。

---

## 実装時の参考情報

### 使用する主要クラス・メソッド

#### 役の検出
```typescript
ComboDetector.detectCombos(board: Board, lastPlacedPosition: Position): Combo[]
```
- 最後に置いたカードを含む全ての役を返す
- 返り値の`Combo`オブジェクトには`type`、`cards`、`positions`が含まれる

#### 役の妥当性検証
```typescript
ComboDetector.checkCombo(cards: Card[], positions: Position[]): ComboType | null
```
- 選択されたカードと位置が役を構成するか検証
- 隣接性のチェックも含まれる

#### 盤面の状態確認
```typescript
Board.getCard(position: Position): Card | null
Board.isEmpty(position: Position): boolean
Board.isFull(): boolean
Board.getEmptyPositions(): Position[]
```

---

## 配置戦略の実装アルゴリズム

### 役成立を狙った配置の探索

```typescript
function findBestPlacement(hand: Card[], board: Board): {
  card: Card,
  position: Position,
  comboType: ComboType | null
} | null {
  const placements = []

  // 手札の各カードについて
  for (const card of hand) {
    // 空きマス全てについて
    for (const pos of board.getEmptyPositions()) {
      // 仮置きをシミュレート
      board.placeCard(card, pos)

      // 役が成立するかチェック
      const combos = ComboDetector.detectCombos(board, pos)

      // 仮置きを戻す
      board.removeCard(pos)

      // 役が成立する場合、候補に追加
      if (combos.length > 0) {
        placements.push({
          card,
          position: pos,
          comboType: combos[0].type  // 最優先の役
        })
      }
    }
  }

  // 優先順位に従ってソート
  placements.sort((a, b) => {
    return getPriority(a.comboType) - getPriority(b.comboType)
  })

  // 最優先の配置を返す（同優先度ならランダム）
  if (placements.length > 0) {
    const topPriority = getPriority(placements[0].comboType)
    const topPlacements = placements.filter(
      p => getPriority(p.comboType) === topPriority
    )
    return topPlacements[Math.floor(Math.random() * topPlacements.length)]
  }

  return null
}

function getPriority(comboType: ComboType | null): number {
  switch (comboType) {
    case 'THREE_CARDS': return 1
    case 'TWO_CARDS_4_9': return 2
    case 'TWO_CARDS_1_4': return 3
    case 'CLEARING_YAKU': return 4
    default: return 999
  }
}
```

---

## テストケース例

### テストケース1：役の見落とし率の検証
- **目的**：20回に1回（5%）の見落としが発生することを確認
- **手順**：
  1. 200回のターンをシミュレート
  2. 各ターンで役が成立する状況を作る
  3. 申告された回数と見落とした回数を記録
- **期待結果**：見落とし率が約5%（許容範囲：3～7%）

### テストケース2：戦略的配置の検証
- **目的**：役が成立する位置にカードを配置することを確認
- **手順**：
  1. 盤面に赤4が配置されている状態を作る
  2. 手札に赤1と青9がある状態でCPUのターンを実行
  3. CPUが赤1を赤4に隣接する位置に配置することを確認
- **期待結果**：役が成立する配置を選択する（見落とさない場合）

### テストケース3：優先順位の検証
- **目的**：複数の役が成立可能な場合、正しい優先順位で選択されることを確認
- **手順**：
  1. 手札に赤1と赤9があり、盤面に赤4が2箇所にある状況を作る
  2. 1を置けば1-4役、9を置けば4-9役が成立する状態
  3. CPUが4-9役を優先して赤9を配置することを確認
- **期待結果**：優先順位に従って4-9役を選択

### テストケース4：ランダム配置の優先順位検証
- **目的**：役が成立しない場合、カードの優先順位に従って配置することを確認
- **手順**：
  1. 役が成立しない空の盤面を用意
  2. 手札に1, 4, 9, 16が全て揃っている状態でCPUのターンを実行
  3. CPUが「1」を優先的に配置することを確認
- **期待結果**：1 > 16 > 9 > 4の順で優先される

---

## 実装時の注意事項

### 1. 乱数生成
- JavaScriptの`Math.random()`を使用
- 見落とし判定：`Math.floor(Math.random() * 20) + 1`で1～20の整数を生成し、20が出たら見落とし

### 2. パフォーマンス最適化
- 配置探索は全マス×全手札の組み合わせをチェックするため、計算量が多い
- 盤面が大きい場合は処理時間に注意
- 仮置き→検証→戻すという操作を効率的に実装する

### 3. 役の申告処理
- 見落とした場合でも、役が検出されていたことをログに記録（デバッグ用）
- ユーザーには「CPUはターンを終了しました」と表示

### 4. コメンタリー（実況）
`Commentary.ts`に定義されているメソッドを適切に呼び出す：
- `Commentary.cpuTurn()`：CPUのターン開始時
- `Commentary.cpuPlacedCard()`：カード配置後
- `Commentary.cpuClaimedCombo()`：役を申告した時
- `Commentary.cpuGotStar()`：星を獲得した時

### 5. デバッグ情報
開発時には以下の情報をログ出力すると便利：
- 探索した配置候補の数
- 選択した配置とその理由（役の種類）
- 見落とし判定の結果

---

## EasyとNormalの比較

| 項目 | Easy | Normal |
|------|------|--------|
| 見落とし率 | 20% | 5% |
| 配置戦略 | ランダム配置のみ | 役成立を狙った戦略的配置 |
| 先読み能力 | なし | あり（仮置きシミュレート） |
| カード優先度 | なし | あり（1 > 16 > 9 > 4） |
| 実装難易度 | 低 | 中 |
| 対象プレイヤー | 初心者 | 中級者 |

---

## 今後の拡張性

CPU（Normal）の実装後、以下の難易度追加が考えられます：

### CPU（Hard）
- 役の見落としなし（100%申告）
- 盤面満杯時の除去カード選択に戦略を追加（役を崩さないように除去）
- 複数ターン先を見据えた配置（将来の役成立を考慮）
- 相手の役成立を妨害する戦略（相手の隣接カードを分断）

---

## バージョン履歴
- **v1.0（2026-02-02）**：初版作成
